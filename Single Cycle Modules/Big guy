`timescale 1ns / 1ps

module ImmGen
(
	input [31:0] ins,
	output reg [63:0] imm_data
);

reg [11:0] ld_imm;
reg [11:0] sd_imm;
reg [11:0] br_imm;
wire [1:0]	sel;

assign sel = ins [6:5];

localparam [1:0]
ld_ins 	= 2'b00,
sd_ins 	= 2'b01,
br_ins 	= 2'b11;

always @ (ins)
begin
	case (sel)
		ld_ins:
			begin
			ld_imm = ins [31:20];
			imm_data = {{52{ins[31]}}, ld_imm};
			end
		
		sd_ins:
			begin
			sd_imm = {ins [31:25], ins[11:7]};
			imm_data = {{52{ins[31]}}, sd_imm};
			end
			
		br_ins:
			begin
			br_imm = {ins [31], ins [7], ins [30:25], ins [11:8]};
			imm_data = {{52{ins[31]}}, br_imm};
			end
			
		default: imm_data = 64'h0000000000000000;
	endcase
end

endmodule

module InsParser
(
	input [31:0] instruction,
	output [6:0] opcode,
	output [4:0] rd,
	output [2:0] funct3,
	output [4:0] rs1,
	output [4:0] rs2,
	output [6:0] funct7
	
);

assign opcode 	= instruction [6:0];
assign rd 		= instruction [11:7];
assign funct3 	= instruction [14:12];
assign rs1		= instruction [19:15];
assign rs2		= instruction [24:20];
assign funct7	= instruction [31:25];

endmodule 

module Mux
(
	input [63:0] a,
	input [63:0] b,
	input  sel,
	
	output reg [63:0]data_out
);

always @ (a, b, sel)
begin
	if (!sel)
		data_out = a;
	else
		data_out = b;
end

endmodule 

module ALU_64_bit
(
	input [63:0]a, b,
	input [3:0] ALUOp,
	
	output reg [63:0] Result,
	output reg ZERO
);

localparam [3:0]
AND = 4'b0000,
OR	= 4'b0001,
ADD	= 4'b0010,
Sub	= 4'b0110,
NOR = 4'b1100;
wire BLT = 4'b1000; 

always @ (ALUOp, a, b)
begin
	case (ALUOp)
		AND: Result = a & b;
		OR:	 Result = a | b;
		ADD: Result = a + b;
		Sub: Result = a - b;
		NOR: Result = ~(a | b);
		BLT: Result = a < b;
		default: Result = 0;
	endcase
	
	if (ALUOp == BLT & Result) ZERO = 1;
	else ZERO = (Result == 0);
end

endmodule 


module registerFile 
  (  input [63:0]WriteData,  
     input [4:0]RS1,  
   input [4:0]RS2,  
   input [4:0]RD,  
   input RegWrite, clk, reset,  
   output reg [63:0]ReadData1,  
   output reg [63:0]ReadData2 
  ); 
  
  reg[63:0] Registers [31:0];    //initialize Registers with random values (using 'initial' block)
  initial    
    begin    
      Registers[0] = 64'd1;    
      Registers[1] = 64'd2;    
      Registers[2] = 64'd3;    
      Registers[3] = 64'd4;    
      Registers[4] = 64'd5;    
      Registers[5] = 64'd6;    
      Registers[6] = 64'd7;    
      Registers[7] = 64'd8;    
      Registers[8] = 64'd9;    
      Registers[9] = 64'd10;    
      Registers[10] = 64'd11;    
      Registers[11] = 64'd12;    
      Registers[12] = 64'd13;    
      Registers[13] = 64'd14;    
      Registers[14] = 64'd15;    
      Registers[15] = 64'd16;    
      Registers[16] = 64'd17;    
      Registers[17] = 64'd18;    
      Registers[18] = 64'd19;    
      Registers[19] = 64'd20;    
      Registers[20] = 64'd21;    
      Registers[21] = 64'd22;    
      Registers[22] = 64'd23;    
      Registers[23] = 64'd24;    
      Registers[24] = 64'd25;    
      Registers[25] = 64'd26;    
      Registers[26] = 64'd27;    
      Registers[27] = 64'd28;    
      Registers[28] = 64'd29;    
      Registers[29] = 64'd30;    
      Registers[30] = 64'd31;    
      Registers[31] = 64'd32;   
    end 
 
 //operation of writing data into a Register should always be done when  
 //positive edge of clock and RegWrite signal is asserted (or set, i.e. High)  
  always @ (posedge clk) 
    begin   
      case(RegWrite)                             
        1'b1 : 		    Registers[RD] <= WriteData;   
      endcase  
    end 
 
  always @ (*)  
    begin   
      if(reset)  
        begin    
          ReadData1 = 64'b0;    
          ReadData2 = 64'b0;   
        end   
      else   
        begin    
          ReadData1 = Registers[RS1];    
          ReadData2 = Registers[RS2];   
        end  
    end  
endmodule 
 
module Data_Memory
(
	input [63:0] Mem_Addr,
	input [63:0] Write_Data,
	input clk, MemWrite, MemRead,
	output reg [63:0] Read_Data
);

	reg [7:0] DataMemory [63:0];

	initial
	begin
		DataMemory[0] = 8'd10;
		DataMemory[1] = 8'd0;
		DataMemory[2] = 8'd0;
		DataMemory[3] = 8'd0;
		DataMemory[4] = 8'd0;
		DataMemory[5] = 8'd0;
		DataMemory[6] = 8'd0;
		DataMemory[7] = 8'd0;
		DataMemory[8] = 8'd8;
		DataMemory[9] = 8'd9;
		DataMemory[10] = 8'd10;
		DataMemory[11] = 8'd11;
		DataMemory[12] = 8'd12;
		DataMemory[13] = 8'd13;
		DataMemory[14] = 8'd14;
		DataMemory[15] = 8'd15;
		DataMemory[16] = 8'd16;
		DataMemory[17] = 8'd17;
		DataMemory[18] = 8'd18;
		DataMemory[19] = 8'd19;
		DataMemory[20] = 8'd20;
		DataMemory[21] = 8'd21;
		DataMemory[22] = 8'd22;
		DataMemory[23] = 8'd23;
		DataMemory[24] = 8'd24;
		DataMemory[25] = 8'd25;
		DataMemory[26] = 8'd26;
		DataMemory[27] = 8'd27;
		DataMemory[28] = 8'd28;
		DataMemory[29] = 8'd29;
		DataMemory[30] = 8'd30;
		DataMemory[31] = 8'd31;
		DataMemory[32] = 8'd0;
		DataMemory[33] = 8'd1;
		DataMemory[34] = 8'd2;
		DataMemory[35] = 8'd3;
		DataMemory[36] = 8'd4;
		DataMemory[37] = 8'd5;
		DataMemory[38] = 8'd6;
		DataMemory[39] = 8'd7;
		DataMemory[40] = 8'd8;
		DataMemory[41] = 8'd9;
		DataMemory[42] = 8'd0;
		DataMemory[43] = 8'd0;
		DataMemory[44] = 8'd0 ;
		DataMemory[45] = 8'd0;
		DataMemory[46] = 8'd0;
		DataMemory[47] = 8'd0;
		DataMemory[48] = 8'd0;
		DataMemory[49] = 8'd0;
		DataMemory[50] = 8'd0;
		DataMemory[51] = 8'd0;
		DataMemory[52] = 8'd0;
		DataMemory[53] = 8'd0;
		DataMemory[54] = 8'd0;
		DataMemory[55] = 8'd0;
		DataMemory[56] = 8'd0;
		DataMemory[57] = 8'd0;
		DataMemory[58] = 8'd0;
		DataMemory[59] = 8'd0;
		DataMemory[60] = 8'd0;
		DataMemory[61] = 8'd0;
		DataMemory[62] = 8'd0;
		DataMemory[63] = 8'd0;
	end
	
	always @ (*)
	begin
		if (MemRead)
			Read_Data = {DataMemory[Mem_Addr+7],DataMemory[Mem_Addr+6],DataMemory[Mem_Addr+5],DataMemory[Mem_Addr+4],DataMemory[Mem_Addr+3],DataMemory[Mem_Addr+2],DataMemory[Mem_Addr+1],DataMemory[Mem_Addr]};
	end
	
	always @ (posedge clk)
	begin
		if (MemWrite)
		begin
			DataMemory[Mem_Addr] = Write_Data[7:0];
			DataMemory[Mem_Addr+1] = Write_Data[15:8];
			DataMemory[Mem_Addr+2] = Write_Data[23:16];
			DataMemory[Mem_Addr+3] = Write_Data[31:24];
			DataMemory[Mem_Addr+4] = Write_Data[39:32];
			DataMemory[Mem_Addr+5] = Write_Data[47:40];
			DataMemory[Mem_Addr+6] = Write_Data[55:48];
			DataMemory[Mem_Addr+7] = Write_Data[63:56];
		end
	end
	
endmodule
 
module Instruction_Memory
(
	input [63:0] Inst_Address,
	output reg [31:0] Instruction
);
	reg [7:0] inst_mem [15:0];
	
	initial
	begin
		inst_mem[0]=8'b10000011;
		inst_mem[1]=8'b00110100;
		inst_mem[2]=8'b10000101;
		inst_mem[3]=8'b00000010;
		inst_mem[4]=8'b10110011;
		inst_mem[5]=8'b10000100;
		inst_mem[6]=8'b10011010;
		inst_mem[7]=8'b00000000;
		inst_mem[8]=8'b10010011;
		inst_mem[9]=8'b10000100;
		inst_mem[10]=8'b00010100;
		inst_mem[11]=8'b00000000;
		inst_mem[12]=8'b00100011;
		inst_mem[13]=8'b00110100;
		inst_mem[14]=8'b10010101;
		inst_mem[15]=8'b00000010;
	end
	
	
	always @(Inst_Address)
	begin
		Instruction={inst_mem[Inst_Address+3],inst_mem[Inst_Address+2],inst_mem[Inst_Address+1],inst_mem[Inst_Address]};
	end
endmodule

module Adder
(
	input [63:0] a,b,
	output reg [63:0] out
);

	always @ (a or b)
		out=a+b;

endmodule

module Program_Counter
(
	input clk,reset,
	input [63:0] PC_In,
	output reg [63:0] PC_Out
);

	initial 
	PC_Out=64'd0;

	always @ (posedge clk or posedge reset)
	begin
		if (reset)
			PC_Out=64'd0;
		else
			PC_Out=PC_In;
	end

endmodule

module ALU_Control
(
	input [1:0] ALUOp, 
	input [3:0] Funct,
	output reg [3:0] Operation
);

	always @ (ALUOp or Funct)
	begin
		case(ALUOp)
			2'b00: Operation = 4'b0010;
			2'b01: 
			begin
			case(Funct[2:0])
				3'b000: Operation = 4'b0110;
				3'b100: Operation = 4'b1000;
			endcase

			2'b10:
			begin 
			case(Funct)
				4'b0000: Operation = 4'b0010;
				4'b1000: Operation = 4'b0110;
				4'b0111: Operation = 4'b0000;
				4'b0110: Operation = 4'b0001;
			endcase
			end
		endcase
	end
	
endmodule

module Control_Unit
(
	input [6:0] Opcode,
	output reg Branch, MemRead, MemtoReg, MemWrite, ALUSrc, RegWrite, 
	output reg [1:0] ALUOp
);

	always @ (Opcode)
	begin
		case (Opcode)
			7'b0110011: // R type
				begin
					Branch = 0;
					MemRead = 0;
					MemtoReg = 0;
					MemWrite = 0;
					ALUSrc = 0;
					RegWrite = 1;
					ALUOp = 2'b10;
				end
			
			7'b0000011: // ld 
				begin
					Branch = 0;
					MemRead = 1;
					MemtoReg = 1;
					MemWrite = 0;
					ALUSrc = 1;
					RegWrite = 1;
					ALUOp = 2'b00;
				end
			7'b0010011: // addi and slli
				begin
					Branch = 0;
					MemRead = 0;
					MemtoReg = 0;
					MemWrite = 0;
					ALUSrc = 1;
					RegWrite = 1;
					ALUOp = 2'b11;
				end
			7'b0100011: // SD
				begin
					Branch = 0;
					MemRead = 0;
					MemtoReg = 1'bx;
					MemWrite = 1;
					ALUSrc = 1;
					RegWrite = 0;
					ALUOp = 2'b00;
				end
			7'b1100011:  //SB
				begin
					Branch = 1;
					MemRead = 0;
					MemtoReg = 1'bx;
					MemWrite = 0;
					ALUSrc = 0;
					RegWrite = 0;
					ALUOp = 2'b01;
				end
		endcase
	end

endmodule 

module RISC_V_Processor(
    input clk, reset,
    output [63:0] PC_Out, output [31:0] instruction, output [4:0] rs1,
    output [4:0] rs2, output [4:0] rd, output [63:0] Write_Data, output [63:0] ReadData1, 
    output [63:0] ReadData2, output [63:0] imm_data, 
    output [63:0] mux1Out, output [63:0] Result, output [63:0] Read_Data_Memory, output [6:0] opcode
    );
    
    wire [63:0] PC_In0; 
    wire [63:0]PC_In1;
    wire [2:0] funct3;
    wire [6:0] funct7;

    
    // for control signals
	wire Branch; wire MemRead; wire MemtoReg; wire MemWrite; wire ALUSrc; 
	wire RegWrite; 
	wire [1:0] ALUOp;
	
	// for the register file
	wire [63:0] ReadData1; wire [63:0] ReadData2;
    wire [63:0] PC_In;
	wire [3:0] Operation;
		
    Program_Counter PC(clk, reset, PC_In, PC_Out);
    Adder add4(PC_Out, 64'd4, PC_In0);
    
    // INSTRUCTION READING
    Instruction_Memory IMem(PC_Out, instruction);
    InsParser IP(instruction, opcode, rd, funct3, rs1, rs2, funct7);
    ImmGen DataExtractor(instruction, imm_data);
    
    // CONTROL UNIT
    Control_Unit CU(opcode, Branch, MemRead, MemtoReg, MemWrite, ALUSrc, RegWrite, ALUOp);
    
    // REGSISTERS READING
    registerFile Registers(Write_Data, rs1, rs2, rd, RegWrite, clk, reset, ReadData1, ReadData2);
    Mux mux1(ReadData2, imm_data, ALUSrc, mux1Out); 
    
    // CALCULATE
    ALU_Control alu_control(ALUOp, {instruction[30], instruction[14:12]}, Operation);
    ALU_64_bit alu(ReadData1, mux1Out, Operation, Result, ZERO);
    
    // DATA MEMORY
    Data_Memory data(Result, ReadData2, clk, MemWrite, MemRead, Read_Data_Memory);
    Mux mux2(Result, Read_Data_Memory, MemtoReg, Write_Data);
    
    // BRANCHING
    Adder add_beq(PC_Out, imm_data * 2'd2, PC_In1);
    Mux mux3(PC_In0, PC_In1, Branch & ZERO, PC_In); 
    
    
endmodule

